import random


class DataUtils:
    #  Note that OSP = Optional Step Printout, shows where sorting steps can be output
    #  Starred comments indicate headings of sections of functions

        #  *Misc and Internal Methods

    def is_ordered(self, data):
        """Takes any dataset and tests if it is in order, returns Bool"""
        ordered = 1
        for i in range(1, len(data)):
            if data[i] < data[i - 1]:
                ordered = 0
        return ordered

    def max_depth(self, nestedlist):
        """Takes any list as input and outputs the number of nestings needed to reach the deepest layer"""
        if isinstance(nestedlist, list):
            if len(nestedlist) == 0:
                depth = 1
            else:
                depth = 1 + max([self.max_depth(l) for l in nestedlist])
        else:
            depth = 0
        return depth

        #  *Randomizing Methods

    def randata(self, length, maximum, duples=1):
        """Takes a length and a maximum value and returns a random data list of the given length with values
         between 0 and the maximum, optional 'duples' argument to turn off duplicate datapoints (default 1)"""
        randlist = []
        if duples == 1:
            randlist = [random.randrange(maximum) for i in range(length)]
        elif duples == 0:
            if length > maximum:
                randlist = [0]
                print("ERROR: cannot have unique distribution longer than range;\n" 
                      "Can either decrease length or increase max")
            else:
                randlist = random.sample(range(0, maximum), length)
        return randlist

    def shuffle(self, data):
        """Takes a data list and shuffles it"""
        return random.sample(data, len(data))

        # *List Sort Methods

    def selsort(self, data, showstep=0):
        """Selection Sort, takes a list and an optional argument to show sorting steps"""
        for cycle in range(len(data)):
            for i in range(cycle, len(data)):
                if data[cycle] > data[i]:
                    data[cycle], data[i] = data[i], data[cycle]
                    if showstep == 1:   #  OSP
                        print(data)
        return data

    def insort(self, data, showstep=0):
        """Insertion Sort, takes a list and an optional argument to show sorting steps"""
        insorted = []
        for i in data:
            insorted.append(i)
            pos = len(insorted) - 1
            if showstep == 1:   #  OSP
                print(insorted)
            while insorted[pos - 1] > insorted[pos] and pos > 0:
                insorted[pos], insorted[pos-1] = insorted[pos-1], insorted[pos]
                pos -= 1
                if showstep == 1:   #  OSP2
                    print(insorted, "Currently Inserting:", i)
        return insorted

    def bubblesort(self, data, showstep=0):
        """Bubble Sort, takes a list and an optional argument to show sorting steps"""
        while 1:
            ordrd = self.is_ordered(data)
            if ordrd == 1:
                return data
            else:
                for i in range(len(data) - 1):
                    if data[i] > data[i + 1]:
                        data[i], data[i+1] = data[i+1], data[i]
                if showstep == 1:  # OSP
                    print(data)

    def mergesort(self, data, showstep=0):
        """Merge Sort, takes a list and an optional argument to show sorting steps"""
        show = showstep
        if len(data) > 1:
            midp = (len(data) // 2)
            left, right = data[:midp], data[midp:]
            left1, right1 = self.mergesort(left, showstep=show), self.mergesort(right, showstep=show)
            if show == 1:   #  OSP
                print(left1, right1)
            # List Merge procedure below, separate for legibility
            result = []
            i = j = 0
            while i < len(left1) and j < len(right1):
                if left1[i] >= right1[j]:
                    result.append(right1[j])
                    j += 1
                else:
                    result.append(left1[i])
                    i += 1
            result += left1[i:]
            result += right1[j:]
            # end of List Merge
        else:
            result = data
        return result

    def quicksort(self, data, showstep=0):
        """Merge Sort, takes a list and an optional argument to show sorting steps and current pivot"""
        step = showstep
        if len(data) < 1:
            return data
        else:
            bot, top, pivot = 0, len(data) - 2, len(data) - 1
            while bot <= top:
                if data[bot] >= data[pivot]:
                    data[bot], data[top], data[pivot] = data[top], data[pivot], data[bot]
                    top, pivot = top - 1, pivot - 1
                    if showstep == 1:
                        print(data, "Pivot %d at Position %d" % (data[pivot], pivot))
                else:
                    bot += 1
            data[:pivot] = self.quicksort(data[:pivot], showstep=step)
            data[pivot + 1:] = self.quicksort(data[pivot + 1:], showstep=step)
        return data

        #  *List Search methods

    def binsearch(self, data, target):
        """Binary Data Search, takes an ***ORDERED*** dataset and a target value, searches binarily for the
         target in the list, returns position of first occurrence of that value in list or 'None' if value is
          not present, along with corresponding printouts"""
        pos = len(data) + 1
        if self.is_ordered(data) == 1:
            head, tail = 0, len(data) - 1
            # searchbound adjustment logic
            while pos == len(data) + 1:
                mid = (head + tail) // 2
                if data[mid] == target:
                    pos = mid
                elif (tail <= head) and (pos == len(data) + 1):
                    pos = -1            #  Error Message 1
                    print("Not in list")
                elif data[mid] > target:
                    tail = mid - 1
                else:
                    head = mid + 1
            #  end search AL
        else:
            pos = -1            #  Error Message 2
            print("ERROR: List not in order")
        return "\nIndex of %d: %d" % (target, pos)


#  Testing methods
d = DataUtils()
dataset = d.randata(20, 20, duples=0)
print(dataset, d.binsearch(d.insort(dataset), 21), "\n---------")
print(d.quicksort(dataset, showstep=1))
